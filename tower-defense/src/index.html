<!doctype html>
<html>
  <head>
    <title>Tower Defense</title>
    <style type="text/css">
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #gameboard {
        width: 100%;
        background-color: rgb(133, 94, 58);
        position: relative;
      }

      .item {
        position: absolute;
        width: 25px;
        height: 25px;
      }
    </style>
  </head>
  <body>
    <div id="gameboard"></div>

    <script type="text/javascript">
      const items = {}
      const board = document.querySelector('#gameboard')
      const boardLength = board.getBoundingClientRect().width
      board.style.height = boardLength.toString() + 'px'
    </script>

    <script type="text/javascript">
      const TILE_SIZE = 25
    
      class Item {
        #key = ''
        _x = 0
        _y = 0

        #width = 0
        #height = 0
        _bottomX = 0
        _bottomY = 0
        
        constructor(x = 0, y = 0, width = TILE_SIZE, height = TILE_SIZE) {
          this.#key = rngesus.id()
          this._x = x
          this._y = y
          this.#width = width
          this.#height = height
          this._bottomX = x + width
          this._bottomY = y + height
        }

        key() {
          return this.#key
        }

        containsPoint(x, y) {
          return x >= this._x && x < this._bottomX && y >= this._y && y < this._bottomY
        }

        isInside(left, top, right, bottom) {
          return this._x >= left && this._x < right && this._y >= top && this._y < bottom
        }

        getX() { return this._x }
        getY() { return this._y }
        getWidth() { return this.#width }
        getHeight() { return this.#height }

        colour() { return '#ffffff' }
        interact(character) { return false }
        hasAgency() { return false }
        isActingAgainstPlayer() { return false }
      }

      class SpawnRoom extends Item {
        constructor() {
          const dimension = snapToTile(boardLength / 5)
          const position = dimension * 2
          super(position, position, dimension, dimension)
        }

        interact() {}

        colour() { return '#808080' }
      }

      class Character extends Item {
        hasAgency() { return true }
      }

      class Opposer extends Character {
        isActingAgainstPlayer() { return true }
      }

      class Player extends Character {
        #destinationX = 0
        #destinationY = 0
        #destinationKey = ''
        #inSpawnRoom = false

        #items = {
          'wood': 0
        }

        colour() { return '#800080' }

        giveItem(itemName, quantity = 1) {
          if (this.#items[itemName] == null) { this.#items[itemName] = 0 }
          this.#items[itemName] += quantity
        }

        attemptTrade(wantedItemName, wantedItemQuantity, offeredItemName, offeredItemQuantity) {
          if (this.#items[wantedItemName] >= wantedItemQuantity) {
            this.#items[wantedItemName] -= wantedItemQuantity
            this.giveItem(offeredItemName, offeredItemQuantity)
          }
        }

        setDestination(x, y, key = '') {
          this.#destinationX = x
          this.#destinationY = y
          this.#destinationKey = key
        }

        update() {
          this._x += this.#getStep(this._x, this.#destinationX)
          this._y += this.#getStep(this._y, this.#destinationY)

          if (this._x === this.#destinationX && this._y === this.#destinationY) {
            // TODO:: Handle updating destination location if item location changes
            interactWithItem(this.#destinationKey)
          }
        }

        hasSpawnRoomStatusChanged() {
          const nowInSpwanRoom = spawnRoom.containsPoint(this.getX(), this.getY())
          const changed = this.#inSpawnRoom !== nowInSpwanRoom
          if (changed) { this.#inSpawnRoom = nowInSpwanRoom }
          return changed
        }

        isInSpawnRoom() { return this.#inSpawnRoom }

        inventoryItems() {
          return Object.keys(this.#items)
        }

        inventoryItemValue(itemName) {
          return this.#items[itemName]
        }

        #getStep(current, destination) {
          return current > destination ? TILE_SIZE * -1 : current < destination ? TILE_SIZE : 0
        }
      }

      class Trader extends Character {
        colour() { return '#000080' }
        interact(character) {
          if (character instanceof Player) {
            character.attemptTrade('wood', 1, 'attractor', 1)
          }
          return true
        }
      }

      class Tree extends Item {
        colour() { return '#008000' }
        interact(character) {
          character.giveItem('wood')
          character.setDestination(0,0)
          removeItemByKey(this.key())
          return true
        }
      }

      class Attractor extends Item {
        colour() { return '#008080' }
        interact(character) {
          // TODO:: work out a way to force any character in a specified radius to interact with it
          if (character.isActingAgainstPlayer() && rngesus.isSuccess(75)) {
            character.setDestination(this.getX(), this.getY())
          }
          return true
        }
      }

      class Random {
        #MAX_VALUE = 4294967295
        #ONE_PERCENT = this.#MAX_VALUE / 100

        #nextIndex = 0
        #source = new Uint32Array(10000)
        constructor() {
          this.#populate()
        }

        #populate() {
          this.#nextIndex = 0
          window.crypto.getRandomValues(this.#source)
        }

        next(upperLimit = 0) {
          let next = this.#source[this.#nextIndex]
          if (upperLimit > 0) {
            const ratio = this.#MAX_VALUE / upperLimit
            next /= ratio
          }
          
          this.#nextIndex++
          if (this.#nextIndex === this.#source.length) { this.#populate() }
          
          return next
        }

        position() {
          const next = this.next(boardLength - TILE_SIZE)
          return snapToTile(next)
        }

        id() {
          return this.next().toString(16).padStart(8, '0')
        }

        isSuccess(percentageRequired) {
          return this.next() >= (this.#ONE_PERCENT * percentageRequired)
        }
      }
    </script>

    <script type="text/javascript">
      const rngesus = new Random()
      const player = new Player()
      const spawnRoom = new SpawnRoom()
      addItem(spawnRoom)
      
      board.addEventListener('click', boardClickHandler)
      
      function snapToTile(position) {
        return Math.floor(position / TILE_SIZE) * TILE_SIZE
      }

      function boardClickHandler(event) {
        if (event.target.classList.contains('item')) {
          const key = event.target.getAttribute('key')
          interactWithItem(key)
        }
      }

      function interactWithItem(key) {
        const item = items[key]
        if (item == null) {
          // TODO:: Use mouse coordinates to work out what square was clicked on so we don't need to click on an item
          return false
        }

        if (item.containsPoint(player.getX(), player.getY())) {
          return item.interact(player)
        } else {
          player.setDestination(item.getX(), item.getY(), item.key())
        }
      }
      
      function maybeSpawnTree() {
        if (rngesus.isSuccess(95.5)) {
          addItem(new Tree(rngesus.position(), rngesus.position()))
        }
      }

      function getItemNode(key) {
        return document.querySelector('#item_' + key)
      }

      function renderItem(item) {
        requestAnimationFrame(() => {
          _renderItem(item)
        })
      }

      function _renderItem(item) {
        const box = document.createElement('div')
        box.classList.add('item')
        box.style.backgroundColor = item.colour()
        box.style.left = item.getX() + 'px'
        box.style.top = item.getY() + 'px'
        box.setAttribute('key', item.key())
        box.setAttribute('id', 'item_' + item.key())

        if (item.getWidth() !== TILE_SIZE) {
          box.style.width = item.getWidth().toString() + 'px'
        }

        if (item.getHeight() !== TILE_SIZE) {
          box.style.height = item.getHeight().toString() + 'px'
        }

        board.appendChild(box)
      }

      function unrenderItemByKey(key) {
        requestAnimationFrame(() => {
          _unrenderItemByKey(key)
        })
      }

      function _unrenderItemByKey(key) {
        const node = getItemNode(key)
        if (node != null) {
          board.removeChild(node)
        }
      }

      function addItem(item) {
        const key = item.key()
        if (items[key] == null) {
          items[key] = item
        }

        const itemNotRendered = getItemNode(key) == null
        const itemIsSpawnRoom = item === spawnRoom
        const itemNotInsideSpawnRoom = !spawnRoom.containsPoint(item.getX(), item.getY())
        const itemNeedsRendering = itemIsSpawnRoom || player.isInSpawnRoom() || itemNotInsideSpawnRoom
        if (itemNotRendered && itemNeedsRendering) {
          renderItem(item)
        }
      }

      function removeItemByKey(key) {
        if (items[key] != null) {
          unrenderItemByKey(key)
          delete items[key]
        }
      }

      function loop() {
        maybeSpawnTree()
        requestAnimationFrame(() => {
          _unrenderItemByKey(player.key())
          player.update()
          
          const changed = player.hasSpawnRoomStatusChanged()
          if (changed) {
            const inside = player.isInSpawnRoom()
            getSpawnRoomItems().forEach(item => {
              if (inside) { _renderItem(item) }
              else { _unrenderItemByKey(item.key()) }
            })
          }

          _renderItem(player)
          _renderInventoryItems()
        })
        setTimeout(loop, 1000)
      }

      function getSpawnRoomItems() {
        return Object.values(items).filter(item => spawnRoom.containsPoint(item.getX(), item.getY()))
      }

      function _renderInventoryItems() {
        const scoreboard = getScoreboard()
        scoreboardChildren = scoreboard.childNodes
        for (const child of scoreboardChildren) { child.parentNode.removeChild(child) }

        const descriptions = player
          .inventoryItems()
          .map(itemName => `${ itemName }: ${ player.inventoryItemValue(itemName)}`)
          .join('<br />')
        
        scoreboard.appendChild(document.createTextNode(descriptions))
      }

      function getScoreboard() {
        let scoreboard = document.querySelector('#scoreboard')
        if (scoreboard == null) {
          scoreboard = document.createElement('div')
          scoreboard.setAttribute('id', 'scoreboard')
          document.body.appendChild(scoreboard)
        }

        return scoreboard
      }

      loop()
    </script>
  </body>
</html>